\section{Introduction}
\label{sec:intro}

% marker
%\textcolor{red}{\textbf{Changes done}}\newline


Modern software applications are large and complex. In addition, they run in
diverse environments and use inputs from variety of data sources. As a result,
predicting safe behavior for such applications can be extremely difficult.
Moreover, giving assurances about the quality of service becomes practically
impossible particularly when the applications are developed using third party
libraries and components. Such applications often exhibit vulnerabilities that
can be exploited by providing malicious inputs. Moreover, diverse data sources
and complex constraints on them make it challenging for programmers to ensure
that all data elements are correctly validated and processed. Any deficiencies
in this process makes applications prone to failures. Such defects can be hard
to detect at the compilation-time, and irrespective of the validation techniques
used, some of them may go undetected and exist in the applications even when the
applications are in production.

The cost of failures can vary considerably depending on the mission-critical
nature of applications. In particular, it would be extremely undesirable for an
unmanned aerial vehicle on its mission to allow the control system to crash in
case of a failure. Instead a suboptimal functioning for a short while might be
acceptable depending on the situation until the system fully stabilizes.
Generally speaking, expectations about the quality of service would largely
depend on how a failure may impact the business. For example, a commercial
online store may not afford a crash while it is listing its products to a
customer. Such unpleasant experiences might result in customers moving to other
online stores making an adverse impact on the business. Similarly, a software
company launching a new product would expect it to be stable while the product
is undergoing beta-testing. Any crashes occurring at that time would result in
negative feedback and loss in the business. To make the matter worse, these
failures may occur in software components that do not possess critical
functionality, and hence, may even get less attention to their quality at the
time of development. Nevertheless, irrespective of the criticality of these
components, if the crash occurs it is equally undesirable.

\lstset{language=Java , caption=Apache Log4j bug example,
label=snippet:exampleRepairing}
\begin{figure}[t]
\begin{lstlisting}
private int substitute() {
  if (priorVariables == null) {
    priorVariables = new ArrayList<String>();
    priorVariables.add(new String(chars, offset, length));
  }
}
\end{lstlisting}
\end{figure}

For example, the code snippet~\ref{snippet:exampleRepairing} depicts a bug that
existed in Apache Log4j library version 2.0-beta9~\cite{ApacheLog4jBug} and made
the logging framework to crash. Hence, the bug was reported as a major bug in
spite of the fact that it occurred in logging component. The object
\code{priorVariables} is a \code{List} of String. On line 4, there is no check
if \code{offset + length > chars.length} or if \code{offset > 0} or \code{length
> 0} which can throw a \code{StringIndexOutOfBounds} exception. In case of such
failure, organizations would rather like to collect diagnostic information to
identify the defects and allow suboptimal behavior or a while until the running
program stabilizes. As long as such suboptimal behavior is within acceptable
limits, the program survival would get higher preference. The bug then can be
fixed in the later versions.

Several approaches have been proposed in the past to ensure that programs can
recover from failures. Some of the approaches are based on static repairing
where the patches are synthesized automatically based on the counter examples
found in the field and using techniques such as model-checking that can be
applied at the compilation-time \cite{}. However, it is not always desirable to
analyze the system for the failure after shutting it down and then relaunch it
after fixing the defect. In order to deal with this practical difficulty, some
dynamic approaches have also been proposed to deal with problems that are
related to memory, data, and incorrect programming constructs such as infinite
loops \cite{}. Most of these approaches work either by identifying and isolating
damaged data or memory portions, or by delaying the execution until the program
stabilizes on its own, or by patching programs on-the-fly and hoping that the
program can recover automatically from the errors. These approaches are
optimistic and work on the assumption that some suboptimal behavior for finite
time under certain conditions is acceptable.

\ignore{Recent approach proposed by Long et al. \cite{} uses technique that
suppresses failures caused by
divide-by-zero and null-dereference errors, and eventually recovering from them
automatically.}

In this work, we propose a novel approach, which is hybrid in the nature and
deals with the failures originated from either malformed strings or incorrect
handling of strings. The approach first identifies program statements statically
that might be vulnerable to string-related failures, and then develops patches
by trying to identify the root-causes of the errors. It also uses dynamic
analysis to improve the precision of the patches generated by the static
analysis. The approach targets string variables for patching firstly, because
strings are used heavily in \java\ APIs and have been found to be common sources
of errors \cite{}, and secondly, because by targeting a specific type of data
the approach can develop patches that are more meaningful and result in the
behavior that would be close to the intended behavior.

This work makes following contributions:
\begin{mylist}
\item We describe a technique (\xref{sec:motivation} and \xref{sec:design}) that
can generate patches by solving constraints on string data mainly statically and
partly dynamically. Since the technique takes into account the constraints on
the data, the patches generated have a higher chance of producing intended
behavior.

\item We present \tool\ (\xref{sec:implementation}) that implements our approach
and effectively generates program patches to handle string-related errors
\cite{}.

\item We present results (\xref{sec:results}) of our study that uses multiple
open-source \java\ applications, and show that \tool\ can effectively produce
patches that save programs from crashing due to failures originating from known
bugs. The study also gives insights into the characteristics of the commonly
occurring string problems.

\item Manual inspection of the automatically generated patches by \tool\ in the
study reveal that in most cases they were semantically similar to the ones
produced by the developers in the later versions. In fact, on couple of
occasions the patches generated by \tool\ were found to be more accurate. This
indicates that \tool\ can guide developers in the process of building patches
for the future versions.
\end{mylist}

% The organization of the paper is as follows. Section~\ref{sec:motivation}
% describes the problem and provides an example to illustrate the proposed
% approach. Section~\ref{sec:architecture} provides the architecture of \tool\ and
% describes the analyses implemented by the tool. Section~\ref{sec:implementation}
% provides implementation details and Section~\ref{sec:evaluation} presents the
% results of the study. Finally, Section~\ref{ref:related work} presents the
% related work and Section~\ref{sec:conclusion} concludes with the outline of the
% future work.









%------------- Deleted part of the section

\ignore{Exception handling attributes to the response of program during runtime
to some
exceptional condition encounter.
Most of the time it changes normal flow of program. In many cases exception
handling is natural part of software execution due to the nature of the
software.
An application which constantly accesses I/O which also includes share resources
may throw exception if another application blocks it.
Here in this paper we discuss and analyze \java\ exceptions and produce repair
patch based on that. \java\  supports two types of exceptions :
\begin{mylist}
	
\item \textbf{Checked exception} which requires explicit \code{throws}
declaration at the method declaration or \code{try-catch} block by the
developers. Such exceptions are handled carefully as they often involves
accessing resources like network, database, file system, I/O etc.
	
\item \textbf{Unchecked exception} which does not enforce similar handing
mechanism as the former one. \code{java.lang.RuntimeException} and its
subclasses and \code{java.lang.Error} are types of unchecked exceptions.
\code{NullPointerException}, \code{ArrayIndexOutOfBound},
\code{ArithmeticException} are examples of common \java\ runtime exceptions.

\end{mylist}

Oracle official documentation says that ``\emph{Here's the bottom line
guideline: If a client can reasonably be expected to recover from an exception,
 make it a checked exception. If a client cannot do anything to recover from the
 exception, make it an unchecked exception}".
 Unchecked exception, particularly runtime exceptions can be thrown from any
 point in the program making them quite unpredictable in nature.
 Due to this extensive testing phase is required to eliminate any bugs and solve
 corner cases.
 Yet many applications suffer unexpected runtime exception causing system crash
 which leads to shutdown or restart.

We find out many applications where system shutdown/restart is expensive due to
their nature.
Notable examples are air traffic control, auto pilot, life support system, smart
power grids, telephone networks, robots like UAV and rovers deployed for
surveillance, reconnaissance and knowledge acquisition in remote locations etc.
These applications are real-time sensitive and there is no room for exception
handling in such system.
Sudden crash involves risk of human life, expensive equipments and critical
services.
Other example includes web applications which uses scrips to dynamically
generate websites and interfaces as per customer preferences.
Many E-commerce websites handles queries, access and process customer and
shopping items data and commits large amount of transactions.
Sudden system crash may result in loss of precious time and data which
eventually may result in a frustrated customers move to other websites.
Many time bad or malicious code leads to some vulnerability to critical
applications and website which can be exploited by attack to orchestrate system
crash. Thought these examples cover a large variety of applications, all of them
point to some concern of \emph{availability}.

Usually, developers tests their code in series of verifications which involves
code review, static and dynamic analysis of the code, generate test cases to
cover as much potential input .Yet may corner cases can be left overlooked which
can cause runtime exceptions.
Multi-threaded applications are also susceptible to erroneous thread
interleaving. One such exception is
\code{java.lang.IllegalMonitorStateException}, when a thread has attempted to
wait on an object's monitor or to notify other threads waiting on an object's
monitor without owning the specified monitor. Applications under adversarial
situation should be considered where deliberate malicious input may cause it to
fail. To recover from such situation, a mechanism is needed which can predict
failure by doing invariant and symbolic analysis. Invariant analysis will detect
particular variables outside legal/safe bound. Static analysis will indicate
to the potential point of failure.
}






\ignore{
\lstset{language=\java\ , caption=Repairing technique on Appache Log4j bug,
label = snippet:exampleRepairingPatched} \begin{figure}[t]
\begin{lstlisting}
private int substitute()
{
  if (priorVariables == null) 
  {
    priorVariables = new ArrayList<String>();
    String temp = null;
    try
    {
    	temp = new String(chars, offset, length);
    }
    catch(StringIndexOutOfBoundsException ex)
    {
     int i = chars.length;
     temp = new String(chars, IndexRepair.getI(offset, length, i),
     IndexRepair.getJ(offset, length, i) length); 
    }
    priorVariables.add(temp);
  }
}
\end{lstlisting}
\end{figure}

Here in the example~\ref{snippet:exampleRepairing}, the object
\code{priorVariables} is a \code{List} of String. In the line 6, there is bug in
Apache Log4j library version 2.0-beta9~\cite{ApacheLog4jBug} which made the
logging framework to crash and was a major bug. In the code there is no check if
\code{offset + length >
chars.lenth} or if \code{offset > 0} or \code{length > 0 }which can throw a 
\code{StringIndexOutOfBounds} exception. . Here the bug was for some cases the
length value passed in the constructor was $0$. In the patched version, our 
patching tool detected the statement automatically and wrap in a try catch 
block with appropiate \code{RunTimeException} type in the
code~\ref{snippet:exampleRepairingPatched}. \code{getI()} and \code{getJ()} are
two static methods defined in the class \code{IndexRepair} which are
instrumented in the byte code.  These two methods repair the last two parameters
of the \code{String(char[]. int, int)} constructor so that it no longer throws
an
Exception. Out automated patch and developers' patch in Apache Log4j version
2.0-rc2.
Behaves exactly the same. Both of them modified the last parameter i.e
\code{length}
so that \code{offset + length = chars.length}.

In this paper we proposed two solution to suppress runtime example and ensure
system survivability. The approach consists of six primary phases

\begin{mylist}
\item \textbf{Taint analysis}: We performed static taint analysis before the
repairing modules to detect the sensitive objects which are leaving the system
via database, network stream, file stream or console. Patching these statements
involving these objects may introduce security concern. We only patch those
objects which never leaves the system. We have used \soot\ \infoflow\ framework
for static taint analysis. We have defined potential taint source and sinks in
the
configuration file. The \infoflow\ frameworks returns all the program
statements which lies in any of the program path from source and sink. We tag
these
statements as unsafe to patch.

\item \textbf{Already handled exception detection using call graph}: There may
be cases where an exception has been handled for a particular statement in its
caller or any predecessor in the call chain. In such scenario the patching would
change the normal program behavior. We have generated call graph using \soot\
call-graph phase (\code{cg}) to detect such instances and exclude those
statements.

\item \textbf{Static constraint evaluation}: We considered constraints in the
program for the objects for effective repairing. In the implementation, we
considered \java\ SE \code{String} API and constraints for a \code{String}
objects
can be length, prefix, suffix etc. We have evaluated these constraints
statically for which the information is also statically available. We regenerate
these objects by solving the constraints.
	
\item \textbf{Dynamic constraint evaluation}: The constraints which can not be
evaluated statically are deferred and special function calls are instrumented in
the byte code which will take care of extracting the constraints and solving
them at the runtime.
	
\item \textbf{Determine type of exception and patching}: The characteristics of
patching is dependent on the type of runtime exception encountered by the
program. A piece of code may throws multiple types of exceptions and all of them
are handled at the time of patching by instrumenting multiple catch blocks.
	
\item \textbf{Optimizing instrumentation}: We introduce couple of optimization
technique to reduce number of instrumentation in the byte code and keep the
overhead of repairing calls at bare minimum so that it does not affect the
application/library performance.

\end{mylist}

The object of the patching is to repair the problem closest to it to minimize
any collateral damage to other parts of the applications hence minimizing the
chance of unintentional data loss/corruption.
}
