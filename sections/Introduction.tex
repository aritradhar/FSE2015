\section{Introduction}
\label{sec:intro}

% marker
%\textcolor{red}{\textbf{Changes done}}\newline

Exception handling attributes to the response of program during runtime to some
exceptional condition encounter.
Most of the time it changes normal flow of program. In many cases exception
handling is natural part of software execution due to the nature of the
software.
An application which constantly accesses I/O which also includes share resources
may throw exception if another application blocks it.
Here in this paper we discuss and analyze \java\ exceptions and produce repair
patch based on that. Java supports two types of exceptions :
\begin{mylist}
	
\item \textbf{Checked exception} which requires explicit \code{throws}
declaration at the method declaration or \code{try-catch} block by the
developers. Such exceptions are handled carefully as they often involves
accessing resources like network, database, file system, I/O etc.
	
\item \textbf{Unchecked exception} which does not enforce similar handing
mechanism as the former one. \code{java.lang.RuntimeException} and its
subclasses and \code{java.lang.Error} are types of unchecked exceptions.
\code{NullPointerException}, \code{ArrayIndexOutOfBound},
\code{ArithmeticException} are examples of common \java\ runtime exceptions.

\end{mylist}

Oracle official documentation says that ``\emph{Here's the bottom line
guideline: If a client can reasonably be expected to recover from an exception,
 make it a checked exception. If a client cannot do anything to recover from the
 exception, make it an unchecked exception}".
 Unchecked exception, particularly runtime exceptions can be thrown from any
 point in the program making them quite unpredictable in nature.
 Due to this extensive testing phase is required to eliminate any bugs and solve
 corner cases.
 Yet many applications suffer unexpected runtime exception causing system crash
 which leads to shutdown or restart.

We find out many applications where system shutdown/restart is expensive due to
their nature.
Notable examples are air traffic control, auto pilot, life support system, smart
power grids, telephone networks, robots like UAV and rovers deployed for
surveillance, reconnaissance and knowledge acquisition in remote locations etc.
These applications are real-time sensitive and there is no room for exception
handling in such system.
Sudden crash involves risk of human life, expensive equipments and critical
services.
Other example includes web applications which uses scrips to dynamically
generate websites and interfaces as per customer preferences.
Many E-commerce websites handles queries, access and process customer and
shopping items data and commits large amount of transactions.
Sudden system crash may result in loss of precious time and data which
eventually may result in a frustrated customers move to other websites.
Many time bad or malicious code leads to some vulnerability to critical
applications and website which can be exploited by attack to orchestrate system
crash. Thought these examples cover a large variety of applications, all of them
point to some concern of \emph{availability}.

Usually, developers tests their code in series of verifications which involves
code review, static and dynamic analysis of the code, generate test cases to
cover as much potential input .Yet may corner cases can be left overlooked which
can cause runtime exceptions.
Multi-threaded applications are also susceptible to erroneous thread
interleaving. One such exception is
\code{java.lang.IllegalMonitorStateException}, when a thread has attempted to
wait on an object's monitor or to notify other threads waiting on an object's
monitor without owning the specified monitor. Applications under adversarial
situation should be considered where deliberate malicious input may cause it to
fail. To recover from such situation, a mechanism is needed which can predict
failure by doing invariant and symbolic analysis. Invariant analysis will detect
particular variables outside legal/safe bound. Static analysis will indicate
to the potential point of failure.


\lstset{language=Java, caption=Example of repairing technique on Appache Commons
Library in \code{fileUtils}, label = snippet:exampleRepairing} 
\begin{figure}[t]
\begin{lstlisting}
public static String getPathNoEndSeparator(String filename){
 return doGetPath(filename, 0);
}
private static String doGetPath(String filename, int separatorAdd)
{
  if (filename == null) {
    return null;
  }
  int prefix = getPrefixLength(filename);
  if (prefix < 0) {
  return null;
  }
  int index = indexOfLastSeparator(filename);
  if ((prefix >= filename.length()) || (index < 0)) {
  return "";
  }
  return filename.substring(prefix, index + separatorAdd);
}
\end{lstlisting}
\end{figure}

\lstset{language=Java, caption=Bug reproduction of code
snippet\ref{snippet:exampleRepairing}, label = snippet:exampleRepairing1}
\begin{figure}[t]
\begin{lstlisting}
String path = "/foo.xml"; 
String s = ApacheBug.getPathNoEndSeparator(path);
\end{lstlisting}
\end{figure}

In the code snippet~\ref{snippet:exampleRepairing}, we have given the source
code of the \code{fileUtils} class of Apache Common IO library. The method
\code{getPathNoEndSeparator()} throws a \code{StringIndexOutOfBounds} exception
when we call \code{getPathNoEndSeparator()} fiven in code
snippet~\ref{snippet:exampleRepairing1}. This exception is thrown by the
statement \code{return filename.substring(prefix, index + separatorAdd)} in the
line no. 17 of~\ref{snippet:exampleRepairing} as \code{prefix > index +
separatorAdd}.

In this paper we proposed two solution to suppress runtime example and ensure
system survivability. The approach consists of six primary phases

\begin{mylist}
\item \textbf{Taint analysis}: We performed static taint analysis before the
repairing modules to detect the sensitive objects which are leaving the system
via database, network stream, file stream or console. Patching these statements
involving these objects may introduce security concern. We only patch those
objects which never leaves the system. We have used \soot\ \infoflow\ framework
for static taint analysis. We have defined potential taint source and sinks in the
configuration file. The \infoflow\ frameworks returns all the program
statements which lies in any of the program path from source and sink. We tag these
statements as unsafe to patch.

\item \textbf{Already handled exception detection using call graph}: There may
be cases where an exception has been handled for a particular statement in its
caller or any predecessor in the call chain. In such scenario the patching would
change the normal program behavior. We have generated call graph using \soot\
call-graph phase (\code{cg}) to detect such instances and exclude those
statements.

\item \textbf{Static constraint evaluation}: We considered constraints in the
program for the objects for effective repairing. In the implementation, we
considered \java\ SE \code{String} API and constraints for a \code{String} objects
can be length, prefix, suffix etc. We have evaluated these constraints
statically for which the information is also statically available. We regenerate
these objects by solving the constraints.
	
\item \textbf{Dynamic constraint evaluation}: The constraints which can not be
evaluated statically are deferred and special function calls are instrumented in
the byte code which will take care of extracting the constraints and solving
them at the runtime.
	
\item \textbf{Determine type of exception and patching}: The characteristics of
patching is dependent on the type of runtime exception encountered by the
program. A piece of code may throws multiple types of exceptions and all of them
are handled at the time of patching by instrumenting multiple catch blocks.
	
\item \textbf{Optimizing instrumentation}: We introduce couple of optimization
technique to reduce number of instrumentation in the byte code and keep the
overhead of repairing calls at bare minimum so that it does not affect the
application/library performance.

\end{mylist}

The object of the patching is to repair the problem closest to it to minimize
any collateral damage to other parts of the applications hence minimizing the
chance of unintentional data loss/corruption.
