\section{Introduction}
\label{sec:intro}

\ignore{Modern software applications are large and complex. In addition, they
run in
diverse environments and get inputs from variety of data sources. As a result,
predicting safe behavior for them at runtime can be difficult.
Moreover, giving assurances about the quality of service becomes practically
impossible when the applications are developed using third party
libraries and components. Such applications often exhibit vulnerabilities that
can be exploited by providing malicious inputs. In addition, diverse data
sources
and complex constraints on them make it challenging for programmers to ensure
that all data elements are correctly validated and processed. Any deficiencies
in this process makes applications prone to failures. Such defects can be hard
to detect at the compilation-time, and irrespective of the validation techniques
used, some of them may go undetected and exist in the applications even when the
applications are in production.}


Developers invest a significant amount of time and human involvement in testing
and verification to make their software production ready. However, in spite of
this effort and the tools used to ensure its safety and security, the software
invariably carries subtle bugs, which are often evident only when the software
throws an exception and/or crashes entirely. The cost of a severe exception or a
crash varies considerably depending on the criticality of the software, and
whether it occurred during production or testing.

\ignore{The cost of failures can vary considerably depending on the
mission-critical
nature of applications. In particular, it would be extremely undesirable for an
unmanned aerial vehicle on its mission to allow the control system to crash in
case of a failure. Instead a suboptimal functioning for a short while might be
acceptable until the system fully stabilizes.}

A software bug in production systems may result in huge monetary losses to the
tune of hundreds of millions of dollars for organizations running third-party
software~\cite{hp, amazon, hershey, nike}. Further, these organizations must
wait for the vendor to release a patch for the offending software, which may
take days or even weeks. If a major software bug strikes during the internal 
acceptance testing, it may significantly hamper the testing progress itself,
thereby affecting the entire software release cycle, and negatively impact the
testing efficiency. Additionally, the software testers may have to wait for the
newer patched version before they resume the testing process. Lastly, any such
crash during a software's beta testing phase might frustrate the public
resulting in rejection of the product itself. In all the above scenarios, it
would be extremely useful if a temporary program patch that not only saves the
program from crashing and moreover, but also guarantees \textit{acceptable} (and
close to the intended) behavior can be applied to the software on-the-fly.

\ignore{The expectations about the quality of service would largely
depend on how a failure may impact the business. For example, a commercial
online store may not afford a crash while it is listing its products to a
customer. Such unpleasant experiences might result in customers moving to other
online stores making an adverse impact on the business. Similarly, a software
company launching a new product would expect it to be stable while the product
is undergoing beta-testing. Any crashes occurring at that time would result in
negative feedback from the users and loss in the business. To make the matter
worse, these
failures may occur in software components that do not possess critical
functionality, and hence, may even get less attention to their quality at the
time of development. Nevertheless, irrespective of the criticality of these
components, if the crash occurs it is equally undesirable.}


\lstset{language=Java , caption=Apache Log4j bug example.,
label=snippet:exampleRepairing1}
\begin{figure}[t]
\begin{lstlisting}
private int substitute() {
  if (priorVariables == null) {
    priorVariables = new ArrayList<String>();
    priorVariables.add(new String(chars, offset, length));
  }
}
\end{lstlisting}
\end{figure}

Software failures that result in crashes often originate from subtle program
bugs that are related to unusual program inputs, unexpected environment changes,
or specific thread schedules. While crashes are always undesirable, they are
particularly annoying when they arise from \textit{non-critical} modules that
are not related to the core software functionality. For example,
Code~\ref{snippet:exampleRepairing1} depicts a bug in Apache Log4j library
version 2.0-beta9~\cite{ApacheLog4jBug} that crashed the entire logging
framework. It was reported as a major bug in spite of the fact that it occurred
in logging component. The object \code{priorVariables} is a \code{List} of
String. On line 4, there is no check on the variables to ensure that invariants
such as \code{offset + length <= chars.length}, \code{offset > 0}, and
\code{length > 0} hold.

In case of failures, rather than allowing the application to crash,
organizations would prefer to collect diagnostic information to identify the
defect, and proceed with a sub-optimal execution run hoping that it will
eventually stabilize, or reveal a few more bugs. In production environments,
program survival would get higher preference as long as the suboptimal behavior
is within acceptable limits. The bug can then be fixed in the later version as
soon as possible. This mechanism is particularly useful if shutting down the
system is either not practical or is less desirable than continuing with a
suboptimal behavior.

\ignore{Several approaches have been proposed in the past to ensure that
programs can
recover from failures. Some of the approaches are based on static repairing
where the patches are synthesized automatically based on the counter examples
found in the field \cite{wei-issta-2010}.
However, it is not always desirable to shut down the system for the post-mortem
analysis and then relaunch it
after fixing the defect. In order to overcome this weakness,
dynamic approaches have been proposed to deal with problems that are
related to memory, data, and incorrect programming constructs such as infinite
loops \cite{Carbin:2011, KlingMCR12, conf/sosp/PerkinsKLABCPSSSWZER09}. Some of
the approaches work either by identifying and isolating
damaged data or memory portions \cite{conf/issre/DemskyR03, conf/icse/DemskyR05,
conf/issta/DemskyEGMPR06}, or by delaying the execution until the program
self-stabilizes \cite{Eom:2012}, or by finding the alternative execution paths
\cite{PezzeRWZ11}, or by disabling suppressing signals and hoping that the
program can recover automatically from the errors \cite{conf/pldi/LongSR14}.
Static approaches strive
for correctness whereas dynamic approaches are typically optimistic and work on
the
assumption that some suboptimal behavior under certain conditions is
acceptable.}

Several approaches have been proposed in the past to automatically fix the
incorrect program behavior by generating program patches. Some of these
approaches are based on static repairing where the patches are synthesized
automatically with the help of counter examples found in the field
\cite{wei-issta-2010}. Such approaches, while striving to achieve correctness,
might require a complete shut down of the system before fixing the defect.
However, it is not always desirable to initiate a system shut down for
post-mortem analysis and synthesis. In contrast, dynamic approaches have been
proposed to overcome this weakness. These approaches deal with problems
affecting memory, data, and incorrect programming constructs, such as infinite
loops \cite{Carbin:2011, KlingMCR12, conf/sosp/PerkinsKLABCPSSSWZER09}, etc.
However, pure dynamic approaches are optimistic and often produce patches that
are suboptimal~\cite{conf/pldi/LongSR14}. These approaches assume
that some suboptimal behavior is acceptable if it does not interfere with the
system's core functionality, and provide correct, but, partial functionality if
the corrupted data structures can be isolated from the rest of the system.

In this work, we propose a novel hybrid approach that deals with failures
originating due to malformed strings, or incorrect handling of strings in \java\
softwares. We target string objects for patching, in particular, for the
following reasons.

First, \java\ applications are typically built using libraries, and
\code{String} APIs are commonly used in third party
libraries~\cite{Kawachiya:2008:ARM:1449764.1449795, gc, techreport}. Frequent
and
often diverse usage of strings in programs is a significant source of errors. In
order to understand the involvement of \java\ string objects in the exceptions
thrown during software failures, we mined
\texttt{stackoverflow}~\cite{stackoverflow} for related posts. We observed that
out of $60$K posts containing \java\ exceptions, almost $33$K posts (\ie\
$>50\%$) were related to \java\ string objects. This data indicates that strings
are frequently used in softwares, and are a significant source of program
exceptions.

Second, we exploit extensive domain knowledge about strings, its well-defined
API, and also the program context to automatically synthesize effective patches,
which identify the precise program location and the data that triggered the
failure, thereby repairing the program close to the point of failure and
preventing failure propagation. In other words, by targeting a specific data
structure, our approach develops precise patches that not only save the running
program from crashing, but also preserves the intended behavior. Our approach
statically identifies program statements vulnerable to string-related failures,
and develops patches by determining origin of errors and constraints on the
strings. The approach further uses dynamic analysis to improve the precision
of the patches generated by the static analysis. 

This work makes following contributions:
\begin{mylist}

\item We present the design and implementation of \tool\ (\xref{sec:overview},
\xref{sec:design} and \xref{sec:implementation}) that generates effective
program patches to handle string-related errors. These patches get activated
only in case of program failures during runtime, and save program from crashing
ensuring its acceptable behavior.
\item We use a finite state machine (FSM) as a formalism (\xref{sec:design}) to
describe the behavior of \java\ \code{String} API, and apply it to drive the
generation of exception-specific patches.

\item We applied \tool\ to several hugely popular open-source libraries to patch
$30$ bugs, several of them rated critical or major, resulting from unhandled
runtime exceptions from \java\ \code{String} APIs. The results of our study
(\xref{sec:results}) indicate that \tool\ can effectively produce patches that
save programs from crashing due to failures originating from known bugs. The
study also gives insights into the characteristics of the commonly occurring
string problems.

\item Manual inspection of the \tool-generated patches reveals that in most
cases they are semantically similar to the ones produced by the developers in
the later versions. %In fact, on couple of occasions the patches generated by
%\tool\ were found to be more accurate.
Thus, \tool\ can also guide developers in the process of building patches for
the future versions.
\end{mylist}

We have made our source code and data sets available to the open source
community at \url{https://github.com/aritradhar/CLOTHO}.









