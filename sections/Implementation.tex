\section{Implementation}
\label{sec:implementation}

We implemented a prototype of \tool\ as described in \xref{sec:design} for
repairing runtime exceptions originating from unhandled \java\ \code{String}
APIs. Our end-to-end toolchain is completely automated and was written in $x$
lines of \java. We leveraged the \soot~\cite{} framework for analysis and
bytecode instrumentation, and \infoflow~\cite{} for static taint analysis.

% We have used our repairing strategy on the \java\ \code{String} API as it is one
% of the most frequent used APIs in commercially available \java\ applications and
% libraries. Another reason to choose \code{String} API was that we have found
% plenty of bugs related to \code{String} in some of the popular libraries and
% applications provided by Apache foundation, Eclipse, ASM etc.

We now briefly describe a few salient features of our implementation.

\subsection{Taint Analysis}

For the taint analysis phase we have used \soot\ \infoflow\ framework. This
framework requires configuration files to fescribe source and sink methods. We
have identified couple of methods and some of them are tabulated in the
table~\ref{tab:TaintSources} and~\ref{tab:TaintSinks} respectively. We have
extended their InfoFlow class and added methods which store the statements in a
\code{HashMap} object as \code{Unit}. The taint analysis phase takes two inputs :
the jar file of the project which is to be analyzed and the \code{SootMethod} 
signature of the entry point of that project.

\subsection{Call Chain Look-up for Already Handled Exception}
\label{subsec:callChainLookUp}

In some scenarios, the developer may put exception handling mechanism in case
there is any runtime exception. In such cases, we shouldn't do any repairing 
as it may change the correct program behavior. There can be two cases.

\begin{mylist}

\item In the current method if the statement is wrapped in try-catch block. In \soot\
the exception handling mechanism is handle by \code{Trap} class. Each \code{Trap}
object has start, end and handler unit. From a particular \code{Unit}, we saw if 
the unit belongs to any of the existing \code{Trap} and tag the \code{Unit} in
a \code{HashMap} object so that later at the repairing phase it can be exclude
from instrumentation.

\item If the exception is handled upper in the call chain, in the case we generate 
\code{CallGhaph} using the project's entry point as the entry point of that call 
graph. For a method we did reverse Breadth First search (BFS) to see from which 
methods it is invoked and also all of its ancestors in the call chain. From there
we retrieve the information if any particular call sight was wrapped in try-catch
block or not. In such case we tag the \code{Unit} in the \code{HashMap} mentioned 
before.

\end{mylist}

\subsection{Constraint Analysis}
\label{subsec:constraint analysis}

\subsubsection{Static Constraint Analysis}
\label{subsubsec:staticConstraint}
~\newline
We did static constraint analysis for all string object to make the patch as much
close as the original object. In the static phase we see all the conditional 
statements. There can be some conditional statements where the constraint can 
be statically determined. E.g \code{if(str.length() == 5}. We collects all these
information in a custom data type and update it. For simplicity, we keep only the 
information such as minimum and maximum length, set of characters which the string
may contains and set of possible prefix. With all these information, we generate 
the string object statically. The sting generation algorithm is described in
Algorithm~\ref{algo:constraint}. 

\subsubsection{Dynamic Constraint Analysis}
\label{subsubsec:dynamicConstraint}
~\newline
We performed dynamic analysis in case the constraint can not be evaluated 
statically e.g. \code{if(str.contains(inputString()))}. In such cases just
before the conditional statement we instrument the bytecode with a static 
invocation which will populate the custom constraint data type and recalculate 
the string object with already existing constraints.


\subsection{String Repairing Phase}
\label{subsec:stringReepairing}

The string repairing phase is divided into two sub-phases.

\subsubsection{Detecting Potential Point of Failure}
\label{subsub:detectingFailure}
~\newline
We have used specification from \java\ SE official documentation and list all
the methods which throws runtime exception. We do forward pass to see if there 
is any invocation of such methods and if we find any we then cross check it 
with the results we got from the taint analysis. We also see if there is already
some exception handling mechanism provided by the developer using the technique 
described in Section~\ref{subsec:callChainLookUp}. We detected such method calls
and wrap them in try-catch block. In the catch block we place the appropriate
exception type as provided by \java\ SE API documentation. 

\subsubsection{Catch Block Instrumentation}
\label{subsub:catchInstrumentation}
~\newline
In this phase we instrument appropiate patching codes inside the catch block.
We used the static constraint evaluation of
Section~\ref{subsubsec:staticConstraint} to statically evaluate the string. In
cases there are more constraints which can't be solved statically, it would instrument
necessary method call so that the constraints would populate and get solved in runtime
~\ref{subsubsec:dynamicConstraint}. In case there is no constraint, we repair the
string in the method calls like \code{substrring}, \code{subSequence}, \code{charAt} etc.
which are dependent on the index arguments. In those cases we used Algorithm
~\ref{algo:stringPatchParametr} to repair them.


\begin{algorithm}
\small
\DontPrintSemicolon
\KwData{String object $Str$ and index set $IS$ which contains ${i}$ or
${i,j}$.}
\KwResult{Repaired index set containin ${Ri}$ or ${Ri,Rj}$ based on input $IS$}
\Begin
{
	$Length \longleftarrow$ length of $Str$\;
	\If{$Length == 0$}
	{
		$Ri, Rj \longleftarrow 0$\;
	}
	\Else
	{
		\If{$i \textgreater j$}
		{
			$Ri \longleftarrow j - 1$;
		}
		\If{$i \textgreater Lengrh$ \bf{OR} $j \textgreater Lengrh$}
		{
			$Ri \longleftarrow Length - 1$ or $Rj \longleftarrow Length - 1$ based on
			condition\; 
		}
		\If{$i \textless 0$ \bf{OR} $j \textless 0h$}
		{
			$Ri \longleftarrow 0$ or $Rj \longleftarrow 0$ based on
			condition\; 
		}
		
		
	}	

}
\caption{String patching based on parameters passed}
\label{algo:stringPatchParametr}
\end{algorithm}