\section{Implementation}
\label{sec:implementation}

We implemented a prototype of \tool\ as described in \xref{sec:design} for
repairing runtime exceptions originating from unhandled \java\ \code{String}
APIs. Our end-to-end toolchain is completely automated and was written in
$\sim$$12.7K$ lines of \java. We leveraged the \soot~\cite{soot} framework for
bytecode analysis and instrumentation, and \infoflow~\cite{infoflow} for static
taint analysis.
% 
% 
% We have used our repairing strategy on the \java\ \code{String} API as it is one
% of the most frequent used APIs in commercially available \java\ applications and
% libraries. Another reason to choose \code{String} API was that we have found
% plenty of bugs related to \code{String} in some of the popular libraries and
% applications provided by Apache foundation, Eclipse, ASM etc.
% 
We now briefly describe a few salient features of our implementation, which is
also available for download at \url{http://goo.gl/d1zcXD}.

\subsection{Taint Analysis}

\infoflow\ performs its taint propagation over \code{Units}, which are \soot's
intermediate representation of the \java\ source code. We extended the
\infoflow\ framework to a) enable seamless coupling with \soot, and b) determine
whether it is safe to patch a given \soot\ \code{Unit}. Specifically, we added
a mapping that retrieves \code{Unit}s for statements to be patched given a
specified method signature. This is relevant since the same statement, say
\code{int x = 1;} has the exact same representation even if it appears more
than once in a same method. We also added a utility method to determine if a
\code{Unit} must be patched if it lies along the path between a source and sink 
in the call graph (as generated by \soot).

%  \item \textbf{Taint Analysis} : We kept \code{HashMap} object to store all the
%  \soot\ \code{Unit} object corresponds to a \code{Boolean} value indicating
%  the fact if the the \code{Unit} is safe to patch or not. In later phases we
%  used this information. As we went through multiple phases of analysis and
%  after each of the phases we did a \soot\ reset, we needed to make sure in the
%  later phases object equality maintained for the \code{Unit} objects. To make
%  sure we kept the \code{PatchingChain} generated from the \code{Jimple} method
%  \code{body} which is the representation of the control flow graph. For each of
%  the \code{Units}, me marked the position of it in the \code{patchingChain} to
%  make sure the comparison with the same \code{Unit} object in later phases also
%  work properly.

%  For the taint analysis phase we have used \soot\ \infoflow\ framework. This
%  framework requires configuration files to describe source and sink methods.
%  We
%  have identified couple of methods and some of them are tabulated in the
%  table~\ref{tab:TaintSources} and~\ref{tab:TaintSinks} respectively. We have
%  extended their InfoFlow class and added methods which store the statements in
%  a
%  \code{HashMap} object as \code{Unit}. The taint analysis phase takes two
% inputs: the jar file of the project which is to be analyzed and the
% \code{SootMethod}
%  signature of the entry point of that project.

\subsection{Call graph analysis}
\label{subsec:callChainLookUp}

\tool\ leverages \soot\ generated call graph to determine both inter- and
intra-method checked runtime exceptions (recall \xref{sec:tool:stage1}). \soot\
uses the \code{Trap} class to manage exception handling for both classes of
exceptions discussed above. Each \code{Trap} object has start, end and handler
unit.  We tagged every \code{Unit} in a \code{HashMap} if it belonged to an
existing \code{Trap}, so as to exclude it from instrumentation during the
repairing phase.

\subsection{Constraint Analysis}
\label{subsec:constraint analysis}

\tool\ makes a forward pass over the \code{Units} identified by the taint
analysis and other program analyses in the first phase to gather constrains over
string literals of interest (recall \xref{sec:tool:stage2}), and builds a
\code{HashMap} of \code{ConstraintDataType}, a custom data type to store and
evaluate these constrains. Specifically, each \code{ConstraintDataType} entry
stores four key parameters---the permissible prefixes, substrings, minimum and
maximum length---that specify constraints corresponding to a \code{String}
literal.

Constraint evaluation over these \code{ConstraintDataType} entries is done as
discussed earlier in Algorithm~\ref{algo:constraint}. However, if the gathered
constraints can not be satisfied statically, \eg\
\code{if(str.contains(userInput()))}, \tool\ instruments the bytecode before the
conditional statement with a static invocation to i) populate the corresponding
\code{ConstraintDataType} entry, and ii) recompute the permissible values of the
string object with already existing constraints (see Code
snippet~\ref{snippet:exCode2}).

% \subsubsection{Static Constraint Analysis}
% \label{subsubsec:staticConstraint}

% \tool\ performs static constraint analysis for all required \code{String}
% objects to make the patched \code{String} as close to the ideal object. In this
% phase, \tool\ analyzes all conditional statements on \code{String} literals to
% statically determine a) prefix, b) suffix, and c) the length of the concerned
% \code{String} literal. For example, \code{if(str.length() == 5} indicates that
% for the program to enter the \code{True} branch of the conditional, \code{str}
% must be of length $5$.

% We collects all these information in a custom data type
% and update it. For simplicity, we keep only the information such as minimum and
% maximum length, set of characters which the string
% may contains and set of possible prefix. With all these information, we generate 
% the string object statically. The sting generation algorithm is described in
% Algorithm~\ref{algo:constraint}. 

% \subsubsection{Dynamic Constraint Analysis}
% \label{subsubsec:dynamicConstraint}
% 
% We performed dynamic analysis in case the constraint can not be evaluated 
% statically e.g. \code{if(str.contains(inputString()))}. In such cases just
% before the conditional statement we instrument the bytecode with a static 
% invocation which will populate the custom constraint data type and recalculate 
% the string object with already existing constraints.

% \subsection{String Repairing Phase}
% \label{subsec:stringReepairing}
% 
% The string repairing phase is divided into two sub-phases.
% 
% \subsubsection{Detecting Potential Point of Failure}
% \label{subsub:detectingFailure}
% 
% We have used specification from \java\ SE official documentation and list all
% the methods which throws runtime exception. We do forward pass to see if there 
% is any invocation of such methods and if we find any we then cross check it 
% with the results we got from the taint analysis. We also see if there is already
% some exception handling mechanism provided by the developer using the technique 
% described in Section~\ref{subsec:callChainLookUp}. We detected such method calls
% and wrap them in try-catch block. In the catch block we place the appropriate
% exception type as provided by \java\ SE API documentation. 
% 
% \subsubsection{Catch Block Instrumentation}
% \label{subsub:catchInstrumentation}
% 
% In this phase we instrument appropiate patching codes inside the catch block.
% We used the static constraint evaluation of
% Section~\ref{subsubsec:staticConstraint} to statically evaluate the string. In
% cases there are more constraints which can't be solved statically, it would instrument
% necessary method call so that the constraints would populate and get solved in runtime
% ~\ref{subsubsec:dynamicConstraint}. In case there is no constraint, we repair the
% string in the method calls like \code{substrring}, \code{subSequence}, \code{charAt} etc.
% which are dependent on the index arguments. In those cases we used
% Algorithm~\ref{algo:stringPatchParametr} to repair them.


% \begin{algorithm}
% \scriptsize
% \DontPrintSemicolon
% \KwData{String object $Str$ and index set $IS$ which contains ${i}$ or
% ${i,j}$.}
% \KwResult{Repaired index set containing ${Ri}$ or ${Ri,Rj}$ based on input $IS$}
% \Begin
% {
% 	$Length \longleftarrow$ length of $Str$\;
% 	\If{$Length == 0$} {
% 		$Ri, Rj \longleftarrow 0$\;
% 	} \Else {
% 		\If{$i \textgreater j$} {
% 			$Ri \longleftarrow j - 1$;
% 		}
% 		\If{$i \textgreater Lengrh$ \bf{OR} $j \textgreater Lengrh$} {
% 			$Ri \longleftarrow Length - 1$ or $Rj \longleftarrow Length - 1$ based on
% 			condition\; 
% 		}
% 		\If{$i \textless 0$ \bf{OR} $j \textless 0h$} {
% 			$Ri \longleftarrow 0$ or $Rj \longleftarrow 0$ based on
% 			condition\; 
% 		}		
% 	}	
% }
% \caption{String patching based on parameters passed}
% \label{algo:stringPatchParametr}
% \end{algorithm}

\subsection{Optimizations}
\label{subsec:optimizations}

\tool\ performs few other optimizations to improve the precision and quality
of the patches.

% \textbf{Call Graph Analysis} : To detect already handled exception we
%  see higher in the call chain if the call site of any one of the ancestors is
%  wrapped in code{try-catch} block or not. To store and retrieve this information
%  efficiently, we keep a \code{HashMap} where key is the method signature and
%  value is an \code{Object} array which contains a \code{Unit} and a
% code{SootClass}.
%  The \code{SootClass} object indicates the exception class by which the
% articular
%  \code{Unit} was handled.

\subsubsection{Minimize constraint analysis}
\label{subsubsec:minimizeConstrintInstrumentation}

\tool\ collects constraints only for those string literals that may be involved
in a runtime exception. For example, if a string object does not involve API
methods that can throw runtime exception, then it is not required to collect and
evaluate constraints on them. This significantly reduces the number of
statements analyzed for instrumentation.
 
% \subsubsection{Minimize conflicts in constraint evaluation}
% \label{subsubsec:minimizeConflictsinConstraintEvaluation}
% ~\newline
% It is likely that in some cases the constrains generated over the string objects
% may never be satisfied due to conflicting constraints. We reduce the number of
% such conflicts by skipping conditional branches that throw exceptions or
% error conditions, like \code{System.err.print()}. In other words, \tool\ only
% considers the conditional expressions in the branches that do not involve any
% exceptions or error paths.

% During the constraint evaluation both statically and dynamically, we
% instrumented methods calls which collect the information about the objects. To
% reduce conflicts at the time of evaluation we skipped some branches in which
% there are some thrown exception or error condition like
% \code{System.err.print()}. We only consider the conditional expressions in the
% branches having no exception or error path.

\begin{table*}[t]
% \setlength{\tabcolsep}{3pt}
\centering
\scriptsize
\begin{tabular}{|l|c|l|r|r||r|r|r|c|c||r|c|r|r|c|}

\hline
\multicolumn{1}{|c|}{\textbf{API}} &
\multicolumn{1}{c|}{\textbf{BugID}} &
\multicolumn{1}{c|}{\textbf{Priority}} &
\multicolumn{1}{c|}{\textbf{$\mathcal{N}_{CG}$}} &
\multicolumn{1}{c||}{\textbf{$\mathcal{N}_{Unit}$}} &
%\multicolumn{1}{c|}{\textbf{$PPI$}} &
\multicolumn{1}{c|}{\textbf{$\mathcal{S}_{U}$}} &
\multicolumn{1}{c|}{\textbf{$\mathcal{F}_{U}$}} &
\multicolumn{1}{c|}{\textbf{$\mathcal{T}$}} &
\multicolumn{1}{c|}{\textbf{$\mathcal{F}_{P}$}} &
\multicolumn{1}{c||}{\textbf{$\mathcal{F}_{P}^{*}$}} &
\multicolumn{1}{c|}{\textbf{$PPI$}} &
\multicolumn{1}{c|}{\textbf{$FCI$}} &
\multicolumn{1}{c|}{\textbf{$\mathcal{IC}_{NO}$}} & %instrumentation with
%optimization
\multicolumn{1}{c|}{\textbf{$\mathcal{IC}_{WO}$}} & %instrumentation without
% optimization
\multicolumn{1}{c|}{\textbf{$\mathcal{RS}_{CE}$}}  % cascaded exception
%new added col
\\

\hline
\code{Aries} & \cite{ARIES1204} & Major &$3.5K$  & $129$ &
$18$ & $2$ & $20$ &  &  & $0.83$ &  & $42$ & $5$ &  \\

\code{Commons CLI1.x} & \cite{CLI193} & Critical & $3.2K$ & $53$ &
$14$ & $2$ & $16$ &  &  & $0.74$ & & $19$& $19$ &  \\

\code{Commons CLI2.x} & \cite{CLI46} & Major & $3.2K$ & $21$ &
$13$ & $3$ & $16$ & $3$ & $1$ & $0.62$ &$1$ & $13$ &$2$ & $\checkmark$\\

\code{Commons Compress} & \cite{COMPRESS26} & Blocker & $4.0K$ & $134$ &
$32$ & $1$ & $33$ &  &  & $0.74$ & & $46$& $4$ & \\

\code{Commons IO} & \cite{IO179} & Major & $3.3K$ & $125$ &
$27$ & $1$ & $28$ &  &  & $0.77$ & & $76$ & $1$ & \\

\code{Commons Lang} & \cite{LANG457} & Major & $5.1K$ & $240$ &
$16$ & $2$ & $18$ &  &  & $0.59$ & & $168$& $8$ &  \\

\code{Commons Math} & \cite{MATH198} & Major & $3.4K$ & $300$ &
$19$ & $2$ & $21$ & $2$ &  & $0.89$ &$1$ & $36$ &$2$ &  \\

\code{Commons Net} & \cite{NET442} & Major & $3.3K$ & $14$ &
$22$ & $1$ & $23$ &  &  & $0.84$ & & $6$ & $1$ & \\

\code{Commons VFS} & \cite{VFS338} & Major &$4.5K$ & $37$ &
$18$ & $1$ & $19$ &  &  & $0.65$ & & $20$ & $2$ &  \\

\code{Derby} & \cite{DERBY4748} & Major & $4.4K$ & $40$ &
$30$ & $2$ & $32$ &  &  & $0.46$ & & $47$ & $6$ &  \\

\code{Eclipse AJ Weaver} & \cite{EclipseBug432874} & Major & $20.6K$ & $50$ &
$17$ & $2$ & $19$ & $2$ & $2$ & $0.98$ & & $4$ & $1$ & $\checkmark$ \\

\code{Eclipse AJ} & \cite{EclipseBug333066} & Major & $25.0K$ &$39$ &
$14$ & $2$ & $16$ &  &  & $0.87$ & & $6$ & $1$ & \\

\code{FlexDK 3.4} &\cite{SDK14417} & Minor & $6.3K$ & $600$ &
$13$ & $2$ & $15$ &  &  & $0.74$ & & $207$ & $25$&  \\

\code{Hama 0.2.0} &\cite{HAMA212}  & Critical & $3.7K$ & $35$ &
$13$ & $1$ & $14$ &  &  & $0.55$ & & $28$ & $5$ &  \\

\code{HBase 0.92.0} &\cite{HBASE4481}  & Critical & $4.8K$ & $61$ &
$24$ & $1$ & $25$ &  &  & $0.83$ & & $13$ & $2$ &  \\

\code{Hive} &\cite{HIVE6986} & Trivial &$4.4K$ & $23$ &
$18$ & $1$ & $19$ &  &  & $0.75$ & & $8$ & $1$ &  \\

\code{HttpClient} &\cite{HTTPCLIENT150} & Major & $3.3K$ & $14$ &
$20$ & $3$ & $23$ &  &  & $0.89$ & & $6$& $1$ &  \\

\code{jUDDI} & \cite{JUDDI292} & Major &$3.2K$ & $70$ &
$28$ & $1$ & $29$ &  &  & $0.85$ & & $10$ & $2$ &  \\

\code{Log4j} & \cite{ApacheLog4jBug} & Major & $3.2K$ & $17$ &
$8$ & $3$ & $11$ &  &  & $0.74$ &  & $6$ &$1$ &  \\

\code{MyFaces Core} & \cite{MYFACES416} & Major  & $4.5K$ & $50$ &
$11$ & $3$ & $14$  &  &  & $0.83$ &  & $4$& $2$ &  \\

\code{Nutch} & \cite{NUTCH1547} & Major & $4.5K$ & $90$ &
$8$ & $3$ & $11$ &  &  & $0.68$ & & $8$ & $1$ &  \\

\code{Ofbiz} & \cite{OFBIZ4237} & Minor & $4.4K$ & $28$ &
$20$ & $3$ & $23$ & $3$ &  & $0.45$ &$1$ & $6$ &$1$ &  \\

\code{PDFBox} & \cite{PDFBOX467} & Major &$4.4K$ & $23$ &
$15$ & $3$ & $18$ &  &  & $0.87$ & & $8$ & $1$ &  \\

\code{Sling Eclipse IDE} & \cite{SLING3095} & Major & $4.5K$ & $58$ &
$5$ & $1$ & $6$ &  &  & $0.59$ &  &$39$ & $6$ &  \\

\code{SOAP} & \cite{SOAP130} & Major &$5.0K$ & $165$ &
$18$ & $3$ & $21$ & $3$ &  & $0.84$ & $1$ & $32$ & $5$ &  \\

\code{SOLR 1.2} & \cite{SOLR331} & Major & $11.0K$ & $200$ &
$12$ & $2$ & $14$ &  &  & $0.89$ &  & $25$ & $4$ &  \\

\code{Struts2} & \cite{WW650} & Major & $16.0K$ & $80$ &
$11$ & $2$ & $13$ &  &  & $0.76$ & & $25$ & $2$ &  \\

\code{Tapestry 5} & \cite{TAP51770} & Major & $6.2K$  & $71$ &
$17$ & $3$ & $20$ &  &  & $0.70$ & & $31$ &$5$ &  \\

\code{Wicket} & \cite{WICKET4387} & Major & $70.0K$ & $68$ &
$20$ & $3$ & $23$ &  &  & $0.81$ & & $16$ & $1$ & \\

\code{XalanJ2} & \cite{XALANJ836} & Major & $3.3K$ & $33$ &
$11$ & $3$ & $14$ &  &  & $0.72$ & &$13$ & $2$ & \\

\hline

\end{tabular}

\caption*{
\scriptsize
\centering
\setlength{\tabcolsep}{3pt}
\begin{tabular}{ll|ll|ll}

$\mathcal{N}_{CG}$ & \# nodes in call graph & $\mathcal{T}$ & \# total cases in
test suite & $FCI$ & Flow Consistency Index\\

$\mathcal{N}_{Unit}$& \# \code{Units} analyzed & $\mathcal{F}_{P}$ & \# failed
tests in patched version w/o forced patching & $\mathcal{IC}_{NO}$
& Instrumentation w/o optimization (recall \xref{subsec:optimizations})\\

$\mathcal{S}_{U}$ & \# successful tests in unpatched & $\mathcal{F}_{P}^{*}$ &
\# failed tests in patched version w/ forced patching & $\mathcal{IC}_{WO}$ &
Instrumentation w/ optimization (recall \xref{subsec:optimizations})\\

$\mathcal{F}_{U}$ & \# failed tests in unpatched & $PPI$ & Patch Precision
Index & $\mathcal{RS}_{CE}$ & Cascaded exception exists
\end{tabular}
}
\caption{\tool's accuracy results when applied to $30$ bugs in popular
open-source libraries.}
\label{tab:results}
\end{table*}

\subsubsection{Minimize patch instrumentation}
\label{subsubsec:minimizePatchInstrumentation}

\tool\ makes a forward pass over all bytecodes to determine if a specific string
object is modified after it has been patched. If the object is not modified then
no further patching of statements capable of throwing \code{NullPointerException} exceptions is
required, since the constraint would have been satisfied in the beginning and it would be valid
as long as the variable is not changed. Similarly, when the API usage is same and none of 
the method parameters are changed, no further patching would be required. This reduces the 
total number of possible
instrumentations required. 

%Further, a string object that involves methods
%capable of throwing runtime exceptions, may not encounter any exceptions during
%execution. Thus, we defer the actual instrumentation required for patching until
%the first exception is thrown, which also minimizes the total amount of code
%instrumentation.


\ignore{
\tool\ makes a forward pass over all bytecodes to determine if a specific string
object is modified after it as been patched. If the object is not modified then
no further patching of statements capable of throwing runtime exceptions is
required, since all constraints will have been satisfied and no exceptions
concerning the object will be thrown. This reduces the total number of possible
instrumentations required. Further, a string object that involves methods
capable of throwing runtime exceptions, may not encounter any exceptions during
execution. Thus, we defer the actual instrumentation required for patching until
the first exception is thrown, which also minimizes the total amount of code
instrumentation.
}