\section{Implementation}
\label{sec:implementation}

We implemented a prototype of \tool\ as described in \xref{sec:design} for
repairing runtime exceptions originating from unhandled \java\ \code{String}
APIs. Our end-to-end toolchain is completely automated and was written in $x$
lines of \java. We leveraged the \soot~\cite{soot} framework for bytecode
analysis and instrumentation, and \infoflow~\cite{infoflow} for static taint
analysis.

% We have used our repairing strategy on the \java\ \code{String} API as it is one
% of the most frequent used APIs in commercially available \java\ applications and
% libraries. Another reason to choose \code{String} API was that we have found
% plenty of bugs related to \code{String} in some of the popular libraries and
% applications provided by Apache foundation, Eclipse, ASM etc.

We now briefly describe a few salient features of our implementation.

\subsection{Taint Analysis}

\infoflow\ performs its taint propagation over \code{Units}, which are \soot's
intermediate representation of the \java\ source code. We extended the
\infoflow\ framework to a) enable seamless coupling with \soot, and b) determine
whether it is safe to patch a given \soot\ \code{Unit}. Specifically, we added
a mapping that retrieves \code{Unit}s for statements to be patched given a
specified function signature. This is relevant since the same statement, say
\code{int x = 1;} has the exact same representation even if it appears in
multiple different functions. We also added a utility method to determine if a
\code{Unit} must be patched if it lies along the path between a source and sink
(recall Tables~\ref{tab:TaintSources} and ~\ref{tab:TaintSinks}) in the call
graph (as generated by \soot).

%  For the taint analysis phase we have used \soot\ \infoflow\ framework. This
%  framework requires configuration files to describe source and sink methods.
%  We
%  have identified couple of methods and some of them are tabulated in the
%  table~\ref{tab:TaintSources} and~\ref{tab:TaintSinks} respectively. We have
%  extended their InfoFlow class and added methods which store the statements in
%  a
%  \code{HashMap} object as \code{Unit}. The taint analysis phase takes two
% inputs: the jar file of the project which is to be analyzed and the
% \code{SootMethod}
%  signature of the entry point of that project.

\subsection{Constraint Analysis}
\label{subsec:constraint analysis}

Once the \infoflow\ taint analysis module identifies the \code{Units} to be
patched, \tool\ invokes its constraint analysis to determine the nature of the
patch. Specifically, patching involves a static component, which determines the
constraints by making a forward pass over the \code{Units} identified by the
taint analysis step, and a dynamic component, which is triggered if the
constraints could not be evaluated statically.

\subsubsection{Static Constraint Analysis}
\label{subsubsec:staticConstraint}

\tool\ performs static constraint analysis for all required \code{String}
objects to make the patched \code{String} as close to the ideal object. In this
phase, \tool\ analyzes all conditional statements on \code{String} literals to
statically determine a) prefix, b) suffix, and c) the length of the concerned
\code{String} literal. For example, \code{if(str.length() == 5} indicates that
for the program to enter the \code{True} branch of the conditional, \code{str}
must be of length $5$.

We collects all these information in a custom data type
and update it. For simplicity, we keep only the information such as minimum and
maximum length, set of characters which the string
may contains and set of possible prefix. With all these information, we generate 
the string object statically. The sting generation algorithm is described in
Algorithm~\ref{algo:constraint}. 

\subsubsection{Dynamic Constraint Analysis}
\label{subsubsec:dynamicConstraint}

We performed dynamic analysis in case the constraint can not be evaluated 
statically e.g. \code{if(str.contains(inputString()))}. In such cases just
before the conditional statement we instrument the bytecode with a static 
invocation which will populate the custom constraint data type and recalculate 
the string object with already existing constraints.

\subsection{String Repairing Phase}
\label{subsec:stringReepairing}

The string repairing phase is divided into two sub-phases.

\subsubsection{Detecting Potential Point of Failure}
\label{subsub:detectingFailure}

We have used specification from \java\ SE official documentation and list all
the methods which throws runtime exception. We do forward pass to see if there 
is any invocation of such methods and if we find any we then cross check it 
with the results we got from the taint analysis. We also see if there is already
some exception handling mechanism provided by the developer using the technique 
described in Section~\ref{subsec:callChainLookUp}. We detected such method calls
and wrap them in try-catch block. In the catch block we place the appropriate
exception type as provided by \java\ SE API documentation. 

\subsubsection{Catch Block Instrumentation}
\label{subsub:catchInstrumentation}

In this phase we instrument appropiate patching codes inside the catch block.
We used the static constraint evaluation of
Section~\ref{subsubsec:staticConstraint} to statically evaluate the string. In
cases there are more constraints which can't be solved statically, it would instrument
necessary method call so that the constraints would populate and get solved in runtime
~\ref{subsubsec:dynamicConstraint}. In case there is no constraint, we repair the
string in the method calls like \code{substrring}, \code{subSequence}, \code{charAt} etc.
which are dependent on the index arguments. In those cases we used
Algorithm~\ref{algo:stringPatchParametr} to repair them.


\begin{algorithm}
\scriptsize
\DontPrintSemicolon
\KwData{String object $Str$ and index set $IS$ which contains ${i}$ or
${i,j}$.}
\KwResult{Repaired index set containin ${Ri}$ or ${Ri,Rj}$ based on input $IS$}
\Begin
{
	$Length \longleftarrow$ length of $Str$\;
	\If{$Length == 0$} {
		$Ri, Rj \longleftarrow 0$\;
	} \Else {
		\If{$i \textgreater j$} {
			$Ri \longleftarrow j - 1$;
		}
		\If{$i \textgreater Lengrh$ \bf{OR} $j \textgreater Lengrh$} {
			$Ri \longleftarrow Length - 1$ or $Rj \longleftarrow Length - 1$ based on
			condition\; 
		}
		\If{$i \textless 0$ \bf{OR} $j \textless 0h$} {
			$Ri \longleftarrow 0$ or $Rj \longleftarrow 0$ based on
			condition\; 
		}		
	}	
}
\caption{String patching based on parameters passed}
\label{algo:stringPatchParametr}
\end{algorithm}
dfdf
ssfs

% 
% \subsection{Data Structures used in Various Phases}
% \label{subsec:dataStructure}
% 
% \begin{mylist}
% \item \textbf{Taint Analysis} : We kept \code{HashMap} object to store all the
% \soot\ \code{Unit} object corresponds to a \code{Boolean} value indicating
% the fact if the the \code{Unit} is safe to patch or not. In later phases we
% used this information. As we went through multiple phases of analysis and
% after each of the phases we did a \soot\ reset, we needed to make sure in the
% later phases object equality maintained for the \code{Unit} objects. To make 
% sure we kept the \code{PatchingChain} generated from the \code{Jimple} method
% \code{body} which is the representation of the control flow graph. For each of 
% the \code{Units}, me marked the position of it in the \code{patchingChain} to 
% make sure the comparison with the same \code{Unit} object in later phases also
% work properly. 
% 
% \item \textbf{Call Graph Analysis} : To detect already handled exception we
% see higher in the call chain if the call site of any one of the ancestors is
% wrapped in code{try-catch} block or not. To store and retrieve this information
% efficiently, we keep a \code{HashMap} where key is the method signature and 
% value is an \code{Object} array which contains a \code{Unit} and a \code{SootClass}.
% The \code{SootClass} object indicates the exception class by which the particular
% \code{Unit} was handled.
% 
% \item \textbf{Constraint Analysis} : We made a custom data type named \code{ConstraintDataType} 
% which contains the information of the constraint for a particular \code{String} object and also evaluate
% the sting when required. The data type has four fields of \code{Value} object which
% indicates the value corresponding to a \soot\ \code{Local} variable. These are minimum
% length, maximum length, an array of prefix and an array of contains (both \code{Character}
% or substring). To manage this data type, we used a \code{HashMap} which is indexed by the
% \code{String} object and the value is \code{ConstraintDataType}.
% 
% \end{mylist}


\subsection{Optimizations}
\label{subsec:optimizations}

\subsubsection{Call Chain Look-up for Already Handled Exception}
\label{subsubsec:callChainLookUp}

In some scenarios, the developer may put exception handling mechanism in case
there is any runtime exception. In such cases, we shouldn't do any repairing
as it may change the correct program behavior. There can be two cases.

\begin{mylist}

\item In the current method if the statement is wrapped in try-catch block. In
\soot\
the exception handling mechanism is handle by \code{Trap} class. Each
\code{Trap}
object has start, end and handler unit. From a particular \code{Unit}, we saw if
the unit belongs to any of the existing \code{Trap} and tag the \code{Unit} in
a \code{HashMap} object so that later at the repairing phase it can be exclude
from instrumentation.

\item If the exception is handled upper in the call chain, in the case we
generate
\code{CallGhaph} using the project's entry point as the entry point of that call
graph. For a method we did reverse Breadth First search (BFS) to see from which
methods it is invoked and also all of its ancestors in the call chain. From
there
we retrieve the information if any particular call sight was wrapped in
try-catch
block or not. In such case we tag the \code{Unit} in the \code{HashMap}
mentioned
before.

\end{mylist}

% \subsubsection{Minimize Patch Instrumentation}
% \label{subsubsec:minimizePatchInstrumentation}
% 
% To reduce number of instrumentation, we analyzed if all the statements which can
% throe runtime exception really requires shielding or not. After an
% instrumentation
% we observed if a particular string object is getting modified or not. In the
% case it
% is not modified and going through same string operation, it does not require any
% patching.
% 
% \subsubsection{Minimize Conflicts in Constraint Evaluation}
% \label{subsubsec:minimizeConflictsinConstraintEvaluation}
% 
% During the constraint evaluation both statically and dynamically, we
% instrumented
% methods calls which collect the information about the objects. To reduce
% conflicts at the time of evaluation
% we skipped some branches in which there are some thrown exception or error
% condition like
% \code{System.err.print()}. We only consider the conditional expressions in the
% branches having
% no exception or error pah.
% 
% \subsubsection{Minimize Constraint Instrumentation}
% \label{subsubsec:minimizeConstrintInstrumentation}
% 
% We instrument statements by which we can generate new string objects based on
% the
% constrains we observed in a forward pass of the program. In case a particular
% string object have not encountered any exception, we deferred the
% instrumentation
% until the first repairing instrumentation. There may be cases that the string
% object never went through such methods which can throw runtime exception, in
% such cases those instrumentation are not necessary.
