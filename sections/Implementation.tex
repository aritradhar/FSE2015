\section{Implementation}
\label{sec:implementation}

We implemented a prototype of \tool\ as described in \xref{sec:tool:design} for
repairing runtime exceptions originating from unhandled \java\ \code{String}
APIs. Our end-to-end toolchain is completely automated and was written in $x$
lines of \java. We leveraged the \soot~\cite{soot} framework for bytecode
analysis and instrumentation, and \infoflow~\cite{infoflow} for static taint
analysis.
% 
% We have used our repairing strategy on the \java\ \code{String} API as it is one
% of the most frequent used APIs in commercially available \java\ applications and
% libraries. Another reason to choose \code{String} API was that we have found
% plenty of bugs related to \code{String} in some of the popular libraries and
% applications provided by Apache foundation, Eclipse, ASM etc.
% 
We now briefly describe a few salient features of our implementation.

\subsection{Taint Analysis}

\infoflow\ performs its taint propagation over \code{Units}, which are \soot's
intermediate representation of the \java\ source code. We extended the
\infoflow\ framework to a) enable seamless coupling with \soot, and b) determine
whether it is safe to patch a given \soot\ \code{Unit}. Specifically, we added
a mapping that retrieves \code{Unit}s for statements to be patched given a
specified function signature. This is relevant since the same statement, say
\code{int x = 1;} has the exact same representation even if it appears in
multiple different functions. We also added a utility method to determine if a
\code{Unit} must be patched if it lies along the path between a source and sink 
in the call graph (as generated by \soot).

%  \item \textbf{Taint Analysis} : We kept \code{HashMap} object to store all the
%  \soot\ \code{Unit} object corresponds to a \code{Boolean} value indicating
%  the fact if the the \code{Unit} is safe to patch or not. In later phases we
%  used this information. As we went through multiple phases of analysis and
%  after each of the phases we did a \soot\ reset, we needed to make sure in the
%  later phases object equality maintained for the \code{Unit} objects. To make
%  sure we kept the \code{PatchingChain} generated from the \code{Jimple} method
%  \code{body} which is the representation of the control flow graph. For each of
%  the \code{Units}, me marked the position of it in the \code{patchingChain} to
%  make sure the comparison with the same \code{Unit} object in later phases also
%  work properly.

%  For the taint analysis phase we have used \soot\ \infoflow\ framework. This
%  framework requires configuration files to describe source and sink methods.
%  We
%  have identified couple of methods and some of them are tabulated in the
%  table~\ref{tab:TaintSources} and~\ref{tab:TaintSinks} respectively. We have
%  extended their InfoFlow class and added methods which store the statements in
%  a
%  \code{HashMap} object as \code{Unit}. The taint analysis phase takes two
% inputs: the jar file of the project which is to be analyzed and the
% \code{SootMethod}
%  signature of the entry point of that project.

\subsection{Constraint Analysis}
\label{subsec:constraint analysis}

\tool\ makes a forward pass over the \code{Units} identified by the taint
analysis to gather constrains over string literals of interest (recall
\xref{sec:tool:design}), and builds a \code{HashMap} of
\code{ConstraintDataType}, a custom data type to store and evaluate these
constrains. Specifically, each \code{ConstraintDataType} entry stores four key
parameters---the permissible prefixes, substrings, minimum and maximum
length---that specify constraints corresponding to a \code{String} literal.

Constraint evaluation over these \code{ConstraintDataType} entries is done as
discussed earlier in Algorithm~\ref{algo:constraint}. However, if the gathered
constraints can not be satisfied statically, \eg\
\code{if(str.contains(userInput()))}, \tool\ instruments the bytecode before the
conditional statement with a static invocation to i) populate the corresponding
\code{ConstraintDataType} entry, and ii) recompute the permissible values of the
string object with already existing constraints (see Code
snippet~\ref{snippet:exCode2}).

% \subsubsection{Static Constraint Analysis}
% \label{subsubsec:staticConstraint}

% \tool\ performs static constraint analysis for all required \code{String}
% objects to make the patched \code{String} as close to the ideal object. In this
% phase, \tool\ analyzes all conditional statements on \code{String} literals to
% statically determine a) prefix, b) suffix, and c) the length of the concerned
% \code{String} literal. For example, \code{if(str.length() == 5} indicates that
% for the program to enter the \code{True} branch of the conditional, \code{str}
% must be of length $5$.

% We collects all these information in a custom data type
% and update it. For simplicity, we keep only the information such as minimum and
% maximum length, set of characters which the string
% may contains and set of possible prefix. With all these information, we generate 
% the string object statically. The sting generation algorithm is described in
% Algorithm~\ref{algo:constraint}. 

% \subsubsection{Dynamic Constraint Analysis}
% \label{subsubsec:dynamicConstraint}
% 
% We performed dynamic analysis in case the constraint can not be evaluated 
% statically e.g. \code{if(str.contains(inputString()))}. In such cases just
% before the conditional statement we instrument the bytecode with a static 
% invocation which will populate the custom constraint data type and recalculate 
% the string object with already existing constraints.

% \subsection{String Repairing Phase}
% \label{subsec:stringReepairing}
% 
% The string repairing phase is divided into two sub-phases.
% 
% \subsubsection{Detecting Potential Point of Failure}
% \label{subsub:detectingFailure}
% 
% We have used specification from \java\ SE official documentation and list all
% the methods which throws runtime exception. We do forward pass to see if there 
% is any invocation of such methods and if we find any we then cross check it 
% with the results we got from the taint analysis. We also see if there is already
% some exception handling mechanism provided by the developer using the technique 
% described in Section~\ref{subsec:callChainLookUp}. We detected such method calls
% and wrap them in try-catch block. In the catch block we place the appropriate
% exception type as provided by \java\ SE API documentation. 
% 
% \subsubsection{Catch Block Instrumentation}
% \label{subsub:catchInstrumentation}
% 
% In this phase we instrument appropiate patching codes inside the catch block.
% We used the static constraint evaluation of
% Section~\ref{subsubsec:staticConstraint} to statically evaluate the string. In
% cases there are more constraints which can't be solved statically, it would instrument
% necessary method call so that the constraints would populate and get solved in runtime
% ~\ref{subsubsec:dynamicConstraint}. In case there is no constraint, we repair the
% string in the method calls like \code{substrring}, \code{subSequence}, \code{charAt} etc.
% which are dependent on the index arguments. In those cases we used
% Algorithm~\ref{algo:stringPatchParametr} to repair them.


% \begin{algorithm}
% \scriptsize
% \DontPrintSemicolon
% \KwData{String object $Str$ and index set $IS$ which contains ${i}$ or
% ${i,j}$.}
% \KwResult{Repaired index set containing ${Ri}$ or ${Ri,Rj}$ based on input $IS$}
% \Begin
% {
% 	$Length \longleftarrow$ length of $Str$\;
% 	\If{$Length == 0$} {
% 		$Ri, Rj \longleftarrow 0$\;
% 	} \Else {
% 		\If{$i \textgreater j$} {
% 			$Ri \longleftarrow j - 1$;
% 		}
% 		\If{$i \textgreater Lengrh$ \bf{OR} $j \textgreater Lengrh$} {
% 			$Ri \longleftarrow Length - 1$ or $Rj \longleftarrow Length - 1$ based on
% 			condition\; 
% 		}
% 		\If{$i \textless 0$ \bf{OR} $j \textless 0h$} {
% 			$Ri \longleftarrow 0$ or $Rj \longleftarrow 0$ based on
% 			condition\; 
% 		}		
% 	}	
% }
% \caption{String patching based on parameters passed}
% \label{algo:stringPatchParametr}
% \end{algorithm}

\subsection{Optimizations}
\label{subsec:optimizations}

\tool\ performs several optimizations to improve the precision and quality of
the patches. We describe a few of them below.

\subsubsection{Checked exceptions \todo{remove redundancy}}
\label{subsubsec:callChainLookUp}
~\newline
Although unlikely, it is possible that the developers may themselves incorporate
code to handle some runtime exceptions. In such cases, \tool\ must not override
the intended program behavior by patching the offending bytecodes. There are two
instances where such exception handling can happen, and we briefly describe
our approach of handling them.

\begin{mylist}

 \item \textbf{Intra-method exception handling}: \soot\ uses the \code{Trap}
class to manage exception handling. Each \code{Trap} object has start, end and
handler unit.  We tagged every \code{Unit} in a \code{HashMap} if it belonged
to an existing \code{Trap}, so as to exclude it from instrumentation during the
repairing phase.

 \item \textbf{Inter-method exception handling}: It is possible that the
developed handled the exception higher up in the call chain. In such scenarios,
we identify call chains (in the call graph) involving the concerned method
perform reverse Breadth First search (BFS) to determine ancestor methods where
the call site was wrapped in \code{try-catch} block or not. In such cases, we
tag the corresponding \code{Unit} in the \code{HashMap} mentioned before.

\end{mylist}

% \textbf{Call Graph Analysis} : To detect already handled exception we
%  see higher in the call chain if the call site of any one of the ancestors is
%  wrapped in code{try-catch} block or not. To store and retrieve this information
%  efficiently, we keep a \code{HashMap} where key is the method signature and
%  value is an \code{Object} array which contains a \code{Unit} and a
% code{SootClass}.
%  The \code{SootClass} object indicates the exception class by which the
% articular
%  \code{Unit} was handled.

\subsubsection{Minimize constraint analysis}
\label{subsubsec:minimizeConstrintInstrumentation}
~\newline
\tool\ collects constraints only for those string literals that may be involved
in a runtime exception. For example, if a string object does not involve API
methods that can throw runtime exception, then it is not required to collect and
evaluate constraints on them. This significantly reduces the number of
statements analyzed for instrumentation.
 
% \subsubsection{Minimize conflicts in constraint evaluation}
% \label{subsubsec:minimizeConflictsinConstraintEvaluation}
% ~\newline
% It is likely that in some cases the constrains generated over the string objects
% may never be satisfied due to conflicting constraints. We reduce the number of
% such conflicts by skipping conditional branches that throw exceptions or
% error conditions, like \code{System.err.print()}. In other words, \tool\ only
% considers the conditional expressions in the branches that do not involve any
% exceptions or error paths.

% During the constraint evaluation both statically and dynamically, we
% instrumented methods calls which collect the information about the objects. To
% reduce conflicts at the time of evaluation we skipped some branches in which
% there are some thrown exception or error condition like
% \code{System.err.print()}. We only consider the conditional expressions in the
% branches having no exception or error path.

\subsubsection{Minimize patch instrumentation}
\label{subsubsec:minimizePatchInstrumentation}
~\newline
\tool\ makes a forward pass over all bytecodes to determine if a specific string
object is modified after it as been patched. If the object is not modified then
no further patching of statements capable of throwing runtime exceptions is
required, since all constraints will have been satisfied and no exceptions
concerning the object will be thrown. This reduces the total number of possible
instrumentations required. Further, a string object that involves methods
capable of throwing runtime exceptions, may not encounter any exceptions during
execution. Thus, we defer the actual instrumentation required for patching until
the first exception is thrown, which also minimizes the total amount of code
instrumentation.

\todo{where do we talk about CHA vs Spark.}